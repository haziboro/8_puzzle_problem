//See Problem.h for implementation details
#include "Problem.h"
#include <iostream>

//constructor
Problem::Problem(std::array<int, 9> initial, std::array<int, 9> goal)
	:initial_state_(initial),
	goal_state_(goal) {}

//initial_state
std::array<int, 9> Problem::initial_state()
{
	return initial_state_;
}

//solvable
bool Problem::solvable(std::array<int, 9> initial)
{
	int invCount = inv_count((std::array<int, 9>) initial);

	// return true if inversion count is even. 
	return (invCount % 2 == 0);
}

//inv_count
int Problem::inv_count(std::array<int, 9> initial)
{
	int inv_count = 0;
	for (int i = 0; i < 9; i++)
		for (int j = i + 1; j < 9; j++)
			// Value 0 is used for empty space 
			if (initial[j] && initial[i] && initial[i] > initial[j]) {
				inv_count++;
			}
	return inv_count;
}

//goal_test
bool Problem::goal_test(std::array<int, 9> state)
{
	/*for (int i = 0;i < 3; i++) {//for testing
		std::cout << state[i];
	}
	std::cout << std::endl;
	for (int i = 3;i < 6; i++) {//for testing
		std::cout << state[i];
	}
	std::cout << std::endl;
	for (int i = 6;i < 9; i++) {//for testing
		std::cout << state[i];
	}
	std::cout << std::endl;
	std::cout << std::endl;*/
	for (int i = 0;i < 9;i++) {
		if (state[i] != goal_state_[i]) {
			return false;
		}
	}
	return true;
}

//make_node
Node* Problem::make_node(std::array<int, 9> state)
{
	Node* initial_node = new Node(state);
	return initial_node;
}

//make_node
Node* Problem::make_node(Node* parent, int action, std::array<int, 9> state)
{
	Node* new_node = new Node(parent, action, state);
	return new_node;
}

//solution
std::stack<Node*> Problem::solution(Node* solutionNode)
{
	std::stack<Node*> solution;
	Node *cur_node = solutionNode;
	bool keepGoing = true; //initialize loop
	while (keepGoing) {
		solution.push(cur_node);
		if (cur_node->parent() == NULL) {
			return solution;
			keepGoing = false;
		}
		else {
			cur_node = cur_node->parent();
		}
	}//end while
}

//successor_fn
std::list<std::array<int,10>> Problem::successor_fn(std::array<int, 9> state)
{
	std::array<int,10> return_vals; //placeholder for list values
	std::list<std::array<int,10>> list; //for storing all pairs

	//find blank index
	int b_idx;
	for (int i = 0; i < 9;i++) {
		if (state[i] == 0) {
			b_idx = i;
		}
	}//end for

	std::array<int, 4> moves;
	for (int i = 0;i < 4;i++) {
		moves[i] = moves_[b_idx][i];
	}
	moves_[b_idx]; //stores possible actions for blank index
	//Determines state's possible actions/results and adds them to the list
	for (int action = 0;action < 4;action++) {
		//copies values of state into result
		if (moves[action] != 9) {
			std::array<int, 9> result;
			for (int f = 0; f < 9; f++) {
				result[f] = state[f];
			}//end for

			//creates new result generated by movement
			result[b_idx]    = state[moves[action]]; //sets blanks old posiion to new value
			result[moves[action]] = 0; //sets new indexes value to blank
			//set return values
			for (int i = 0;i < 9;i++) {
				return_vals[i] = result[i];
			}
			return_vals[9] = action; //set action as 10th value

			//pushes action/result pair to list
			list.push_front(return_vals);
		}//end if
	}//end for
	
	//returns list of action/result pairs
	return list;


}

//step_cost
int Problem::step_cost(Node* parent, int action, Node* successor)
{
	//Get parent and successor states
	std::array<int, 9> p_state = parent->state();
	std::array<int, 9> s_state = successor->state();
	//placeholders for path cost of parent and succesor
	int p_cost = 0; int s_cost = 0;

	//accesses costs_, determining how many actions each tile is from it's desired index
	for (int i = 0;i < 9;i++) {
		p_cost = p_cost + costs_[p_state[i]][i];
		s_cost = s_cost + costs_[s_state[i]][i];
	}//end for
	successor->set_path(s_cost); //sets successor path to total cost calculated
	return p_cost - s_cost;//return overall change in progress between nodes

}